/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tpbitcoin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import org.bitcoinj.core.*;
import org.bitcoinj.params.MainNetParams;
import org.bitcoinj.params.UnitTestParams;
import org.bitcoinj.script.ScriptException;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.net.URL;
import java.security.NoSuchAlgorithmException;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

import static tpbitcoin.ImpactUtils.expectedYearsToMineABlock;

public class App {



    public static void main(String[] args) throws NoSuchAlgorithmException {

        //Q1  Hashrate
        double localHashrate = new HashRateEstimator(5000,5).estimate();
        System.out.println("\n--> Q1 : \n");
        System.out.println("    Estimated hashrate: " + localHashrate + " hashes per second");

        // Q2: latest  block  from mainet (bitcoin blockchain) and its predecessor
        Context context   = new Context(new UnitTestParams());
        Explorer explorer = new Explorer();
        NetworkParameters params = MainNetParams.get();

        System.out.println("\n--> Q2 : \n");

        // Test de getLatestHash
        String latestHash = explorer.getLatestHash();
        System.out.println("    Latest Block Hash: " + latestHash);
        assert latestHash != null && !latestHash.isEmpty() : "Latest hash should not be null or empty";

        // Test de getRawblockFromHash
        byte[] rawBlock = explorer.getRawblockFromHash(latestHash);
        System.out.println("    Raw Block Data Length: " + (rawBlock != null ? rawBlock.length : "null"));
        assert rawBlock != null && rawBlock.length > 0 : "Raw block data should not be null or empty";

        // Test de getBlockFromHash
        Block block = explorer.getBlockFromHash(params, latestHash);
        assert block != null : "    Block should not be null";

        // Affichage de quelques informations sur le bloc récupéré pour vérification
        System.out.println("    Block Info:");
        System.out.println("        Hash: " + block.getHashAsString());
        System.out.println("        Version: " + block.getVersion());
        System.out.println("        Previous Block Hash: " + block.getPrevBlockHash());
        System.out.println("        Merkle Root: " + block.getMerkleRoot());
        System.out.println("        Timestamp: " + block.getTimeSeconds());
        System.out.println("        Nonce: " + block.getNonce());
        System.out.println("        Number of Transactions: " + Objects.requireNonNull(block.getTransactions()).size());


        // Q3 Some TXs
        // Affichage des transactions du bloc, en particulier la première
        System.out.println("\n--> Q3 : \n");
        List<Transaction> transactions = block.getTransactions();
        if (!transactions.isEmpty()) {
            // Affichage de la première transaction
            Transaction firstTransaction = transactions.get(0);
            System.out.println("\n  First Transaction Info:");
            System.out.println("        Transaction Hash: " + firstTransaction.getTxId());
            System.out.println("        Inputs Count: " + firstTransaction.getInputs().size());
            System.out.println("        Outputs Count: " + firstTransaction.getOutputs().size());
            System.out.println("        Outputs Values:");
            for (TransactionOutput output : firstTransaction.getOutputs()) {
                System.out.println("        Value: " + output.getValue().toFriendlyString());
                // Affichez également l'adresse du destinataire si disponible
                try {
                    System.out.println("        Address: " + output.getScriptPubKey().getToAddress(params).toString());
                } catch (ScriptException e) {
                    System.out.println("        Address: Unable to decode");
                }
            }

            System.out.println("    Inputs:");
            firstTransaction.getInputs().forEach(input -> System.out.println("        " + input.toString()));
            System.out.println("    Outputs:");
            firstTransaction.getOutputs().forEach(output -> System.out.println("        " + output.toString()));
        } else {
            System.out.println("No transactions found in this block.");
        }


        // Q4 Mine a new block
        System.out.println("\n--> Q4 : \n");
        Miner miner = new Miner(context.getParams());
        ArrayList<Transaction> txs = new ArrayList<>(); // Liste vide pour l'exemple

        // Générer une nouvelle paire de clés pour simuler le mineur
        ECKey key = new ECKey();
        byte[] pubKey = key.getPubKey();

        // Obtenir le dernier bloc (ici simplifié par l'obtention du hash du dernier bloc)
        Block lastBlock = explorer.getBlockFromHash(params, latestHash);

        // Miner le nouveau bloc
        Block newBlock = miner.mine(lastBlock, txs, pubKey);

        // Vérifier et afficher des informations sur le nouveau bloc miné
        if (newBlock != null) {
            System.out.println("Nouveau bloc miné avec succès !");
            System.out.println("Hash du bloc: " + newBlock.getHashAsString());
            // Afficher d'autres informations pertinentes sur le bloc
        } else {
            System.out.println("Le minage du nouveau bloc a échoué.");
        }


        // Q6
        System.out.println("\n--> Q6 : \n");
        // Difficulté utilisée pour le minage dans le TP
        BigInteger easyDifficulty = BigInteger.valueOf(Miner.EASY_DIFFICULTY_TARGET);

        // Calcul du temps moyen nécessaire pour miner un bloc
        long expectedTime = ImpactUtils.expectedMiningTime((long) localHashrate, easyDifficulty);

        System.out.println("\n  Temps Moyen Pour Miner un Bloc :\n");
        System.out.println("        Avec un hashrate de " + (localHashrate / 1e9) + " GH/s,");
        System.out.println("        et une difficulté de réseau de " + easyDifficulty + ",");
        System.out.println("        le temps moyen pour miner un bloc est de " + expectedTime + " secondes.");

        // Q7
        System.out.println("\n--> Q7 : \n");
        double expectedYears = expectedYearsToMineABlock((long) localHashrate, easyDifficulty);
        System.out.println("Le nombre d'années moyen pour miner un bloc sur notre machine est : " + expectedYears);


        // Q8
        System.out.println("\n--> Q8 :\n");
        BigInteger easyDiff = BigInteger.valueOf(Miner.EASY_DIFFICULTY_TARGET);
        double networkHashrate = ImpactUtils.calculateNetworkHashrate(easyDiff);
        System.out.println("Le hashrate estimé du réseau avec la difficulté simplifiée est d'environ " + networkHashrate
                + " GH/s.");


        // Q9
        System.out.println("\n--> Q9 :\n");
        // Spécifications du Bitmain Antminer S19 Pro
        double capacityInTHs = 110; // Capacité de hashage en TH/s
        double powerInWatts = 3250; // Puissance consommée en Watts

        // Calcul de l'énergie consommée par le réseau en supposant que tous les mineurs
        // utilisent le Bitmain Antminer S19 Pro, sur les dernières 24 heures
        double energyConsumed = ImpactUtils.calculateEnergyConsumed(capacityInTHs, powerInWatts);

        System.out.println("Énergie consommée par le réseau Bitcoin sur 24 heures (en utilisant Bitmain Antminer S19 Pro): "
                + energyConsumed + " kWh");


        // Q9/Q10 energy w/ most profitable hardware
        System.out.println("\n--> Q10 :\n");
        Gson gson = new GsonBuilder()
                .registerTypeAdapter(YearMonth.class,new YearMonthAdapter())
                .create();
        List<MiningHardware> hardwares = new ArrayList<>();

        URL resource = App.class.getClassLoader().getResource("hardware.json");
        try(BufferedReader reader = new BufferedReader(new FileReader(Objects.requireNonNull(resource).getFile()))) {
            Type listType = new TypeToken<ArrayList<MiningHardware>>(){}.getType();
            hardwares = gson.fromJson(reader,listType);
        } catch (Exception e) {
            System.err.println("error opening/reading hardware.json "+ e.getMessage());
        }

        // Continuation du code pour Q9/Q10...
        double costOfElectricity = 0.1; // Coût de l'électricité en $/kWh

    // Identifier l'équipement le plus efficace
        MiningHardware mostEfficientHardware = hardwares.stream()
                .min(Comparator.comparingDouble(h -> h.getPower() / (double) h.getTeraHashRate()))
                .orElseThrow();

    // Identifier l'équipement le plus ancien mais rentable selon une certaine logique
    // Ici, pour simplifier, prenons l'exemple du premier équipement
        MiningHardware oldestProfitableHardware = hardwares.get(0); // Ceci est un placeholder

    // Calculer le coût d'opération quotidien pour l'équipement le plus efficace
        double dailyCostMostEfficient = mostEfficientHardware.operatingDailyCost(costOfElectricity);

    // Calculer le coût d'opération quotidien pour l'équipement le plus ancien mais rentable
        double dailyCostOldestProfitable = oldestProfitableHardware.operatingDailyCost(costOfElectricity);

        System.out.println("Coût d'opération quotidien pour l'équipement le plus efficace: " + dailyCostMostEfficient + " $");
        System.out.println("Coût d'opération quotidien pour l'équipement le plus ancien mais rentable: " + dailyCostOldestProfitable + " $");

    // Q11 (Check FingridAPI.java)

      //  final String API_KEY = "5149cba6ecdd4fff983747c0237699be";
        // Obtenir la consommation électrique totale de la Finlande pour les dernières 24 heures
      //  long totalConsumption = HourlyConsumption.getFinnishConsumptionLast24h(API_KEY);

        // Afficher les résultats
      //  System.out.println("Consommation électrique totale de la Finlande pour les dernières 24 heures (en kWh): " + totalConsumption);



    }

}
